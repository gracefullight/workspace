import { existsSync } from "node:fs";
import { mkdir, readFile, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { OPENCODE_EVENTS } from "@/constants/opencode-events";
import { BUILTIN_TOOLS } from "@/constants/tools";
import type { MimicContext } from "@/core/context";
import type { StateManager } from "@/core/state";
import { formatCapabilityType } from "@/lib/i18n";
import { findRepresentativePattern } from "@/modules/knowledge/instincts";
import type { CapabilityType, Domain, EvolvedCapability, Pattern } from "@/types";
import { generateId } from "@/utils/id";

interface EvolutionSuggestion {
  type: CapabilityType;
  name: string;
  description: string;
  reason: string;
  pattern: Pattern;
}

function generateToolCode(name: string, description: string, pattern: Pattern): string {
  const funcName = name.replace(/-/g, "_");
  return `// ðŸ“¦ Auto-generated by Mimic
// Pattern: ${pattern.description} (${pattern.count}x)
// Generated: ${new Date().toISOString()}

export const ${funcName} = (plugin) => ({
  tool: {
    "${name}": {
      description: "${description}",
      args: {},
      async execute() {
        // TODO: Implement your logic here
        // This was generated from pattern: ${pattern.description}
        return "ðŸ“¦ ${name} executed!";
      },
    },
  },
});

export default ${funcName};
`;
}

function generateHookCode(name: string, _description: string, pattern: Pattern): string {
  const filename = pattern.description;
  return `// ðŸ“¦ Auto-generated by Mimic
// Pattern: ${pattern.description} (${pattern.count}x)
// Generated: ${new Date().toISOString()}

export const ${name.replace(/-/g, "_")} = (plugin) => ({
  async event({ event }) {
    if (event.type === "${OPENCODE_EVENTS.FILE_EDITED}") {
      const filename = event.properties?.filename;
      if (filename?.includes("${filename}")) {
        console.log("ðŸ“¦ [Mimic] Detected change in watched file: ${filename}");
        // TODO: Add your custom logic here
      }
    }
  },
});

export default ${name.replace(/-/g, "_")};
`;
}

function generateSkillCode(name: string, description: string, pattern: Pattern): string {
  return `// ðŸ“¦ Auto-generated by Mimic
// Pattern: ${pattern.description} (${pattern.count}x)
// Generated: ${new Date().toISOString()}

export const ${name.replace(/-/g, "_")} = (plugin) => ({
  async event({ event }) {
    // Auto-triggered skill: ${description}
    if (event.type === "${OPENCODE_EVENTS.SESSION_CREATED}") {
      console.log("ðŸ“¦ [Mimic] Skill ${name} activated");
      // TODO: Implement automated behavior
    }
  },
});

export default ${name.replace(/-/g, "_")};
`;
}

function generateMcpConfig(name: string, _description: string, pattern: Pattern): object {
  return {
    [name]: {
      type: "local",
      command: ["echo", `MCP server for ${pattern.description}`],
      enabled: false,
    },
  };
}

function generateAgentMarkdown(name: string, description: string, pattern: Pattern): string {
  return `---
description: ${description}
mode: subagent
tools:
  read: true
  glob: true
  grep: true
  bash: false
  edit: false
---

# ðŸ“¦ ${name}

Auto-generated by Mimic from pattern: ${pattern.description} (${pattern.count}x)

## Focus Area

This agent specializes in tasks related to: ${pattern.description}

## Context

- Pattern detected: ${pattern.type}
- Usage count: ${pattern.count}
- First seen: ${new Date(pattern.firstSeen).toISOString()}

## How To Help

Analyze and assist with tasks matching this pattern.
Provide focused, expert guidance in this specific area.

## Remember

- Stay focused on the pattern's domain
- Leverage the observed usage patterns
- Adapt to the user's workflow
`;
}

type EvolutionOutput = { filePath: string; content: string };

async function readOpencodeConfig(configPath: string): Promise<Record<string, unknown>> {
  if (!existsSync(configPath)) return {};

  try {
    const parsed = JSON.parse(await readFile(configPath, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      return {};
    }
    return parsed as Record<string, unknown>;
  } catch {
    return {};
  }
}

async function buildMcpEvolution(
  ctx: MimicContext,
  suggestion: EvolutionSuggestion,
): Promise<EvolutionOutput> {
  const opencodeDir = join(ctx.directory, ".opencode");
  if (!existsSync(opencodeDir)) {
    await mkdir(opencodeDir, { recursive: true });
  }

  const configPath = join(ctx.directory, "opencode.json");
  const config = await readOpencodeConfig(configPath);
  const mcpConfig = generateMcpConfig(suggestion.name, suggestion.description, suggestion.pattern);

  const mcp = { ...((config.mcp as Record<string, unknown>) || {}), ...mcpConfig };
  const content = JSON.stringify({ ...config, mcp }, null, 2);

  return { filePath: configPath, content };
}

async function buildAgentEvolution(
  ctx: MimicContext,
  suggestion: EvolutionSuggestion,
): Promise<EvolutionOutput> {
  const agentsDir = join(ctx.directory, ".opencode", "agents");
  if (!existsSync(agentsDir)) {
    await mkdir(agentsDir, { recursive: true });
  }

  return {
    content: generateAgentMarkdown(suggestion.name, suggestion.description, suggestion.pattern),
    filePath: join(agentsDir, `${suggestion.name}.md`),
  };
}

function buildPluginContent(suggestion: EvolutionSuggestion): string {
  switch (suggestion.type) {
    case "command":
    case "shortcut":
      return generateToolCode(suggestion.name, suggestion.description, suggestion.pattern);
    case "hook":
      return generateHookCode(suggestion.name, suggestion.description, suggestion.pattern);
    case "skill":
      return generateSkillCode(suggestion.name, suggestion.description, suggestion.pattern);
    default:
      return generateToolCode(suggestion.name, suggestion.description, suggestion.pattern);
  }
}

async function buildPluginEvolution(
  ctx: MimicContext,
  suggestion: EvolutionSuggestion,
): Promise<EvolutionOutput> {
  const pluginsDir = join(ctx.directory, ".opencode", "plugins");
  if (!existsSync(pluginsDir)) {
    await mkdir(pluginsDir, { recursive: true });
  }

  return {
    content: buildPluginContent(suggestion),
    filePath: join(pluginsDir, `${suggestion.name}.js`),
  };
}

async function buildEvolutionOutput(
  ctx: MimicContext,
  suggestion: EvolutionSuggestion,
): Promise<EvolutionOutput> {
  if (suggestion.type === "mcp") {
    return buildMcpEvolution(ctx, suggestion);
  }

  if (suggestion.type === "agent") {
    return buildAgentEvolution(ctx, suggestion);
  }

  return buildPluginEvolution(ctx, suggestion);
}

function createCapabilityFromSuggestion(suggestion: EvolutionSuggestion): EvolvedCapability {
  return {
    id: generateId(),
    type: suggestion.type,
    name: suggestion.name,
    description: suggestion.description,
    createdAt: new Date().toISOString(),
    fromPattern: suggestion.pattern.id,
  };
}

function updateEvolutionState(
  state: Awaited<ReturnType<StateManager["read"]>>,
  capability: EvolvedCapability,
  suggestion: EvolutionSuggestion,
): void {
  state.evolution.capabilities.push(capability);
  state.evolution.lastEvolution = new Date().toISOString();

  const pattern = state.patterns.find((p) => p.id === suggestion.pattern.id);
  if (pattern) {
    pattern.surfaced = true;
  }
}

export function suggestEvolution(pattern: Pattern, ctx: MimicContext): EvolutionSuggestion | null {
  switch (pattern.type) {
    case "tool":
      if (pattern.count >= 10) {
        const toolName = pattern.description;
        if (BUILTIN_TOOLS.has(toolName)) {
          return null;
        }
        return {
          type: "shortcut",
          name: `quick-${pattern.description.toLowerCase().replace(/[^a-z0-9]/g, "-")}`,
          description: ctx.i18n.t("evolution.suggest.tool.description", {
            pattern: pattern.description,
          }),
          reason: ctx.i18n.t("evolution.suggest.tool.reason", { count: pattern.count }),
          pattern,
        };
      }
      break;

    case "file":
      if (pattern.count >= 5) {
        return {
          type: "hook",
          name: `watch-${pattern.description.split("/").pop()?.replace(/\./g, "-") || "file"}`,
          description: ctx.i18n.t("evolution.suggest.file.description", {
            pattern: pattern.description,
          }),
          reason: ctx.i18n.t("evolution.suggest.file.reason", { count: pattern.count }),
          pattern,
        };
      }
      break;

    case "commit":
      if (pattern.count >= 3) {
        return {
          type: "command",
          name: `commit-${pattern.description.slice(0, 20).replace(/\s+/g, "-").toLowerCase()}`,
          description: ctx.i18n.t("evolution.suggest.commit.description", {
            pattern: pattern.description,
          }),
          reason: ctx.i18n.t("evolution.suggest.commit.reason", { count: pattern.count }),
          pattern,
        };
      }
      break;

    case "sequence":
      if (pattern.count >= 5) {
        return {
          type: "agent",
          name: `${pattern.description.slice(0, 15).replace(/\s+/g, "-").toLowerCase()}-specialist`,
          description: ctx.i18n.t("evolution.suggest.sequence.agent.description", {
            pattern: pattern.description,
          }),
          reason: ctx.i18n.t("evolution.suggest.sequence.agent.reason", { count: pattern.count }),
          pattern,
        };
      }
      if (pattern.count >= 3) {
        return {
          type: "skill",
          name: `auto-${pattern.description.slice(0, 15).replace(/\s+/g, "-").toLowerCase()}`,
          description: ctx.i18n.t("evolution.suggest.sequence.skill.description", {
            pattern: pattern.description,
          }),
          reason: ctx.i18n.t("evolution.suggest.sequence.skill.reason", { count: pattern.count }),
          pattern,
        };
      }
      break;
  }

  return null;
}

export async function getEvolutionSuggestions(ctx: MimicContext): Promise<EvolutionSuggestion[]> {
  const state = await ctx.stateManager.read();
  const suggestions: EvolutionSuggestion[] = [];

  for (const pattern of state.patterns) {
    if (pattern.surfaced) continue;

    const suggestion = suggestEvolution(pattern, ctx);
    if (suggestion) {
      suggestions.push(suggestion);
    }
  }

  return suggestions;
}

export async function evolveCapability(
  ctx: MimicContext,
  suggestion: EvolutionSuggestion,
): Promise<{ capability: EvolvedCapability; filePath: string }> {
  const state = await ctx.stateManager.read();
  const { filePath, content } = await buildEvolutionOutput(ctx, suggestion);
  await writeFile(filePath, content, "utf-8");

  const capability = createCapabilityFromSuggestion(suggestion);
  updateEvolutionState(state, capability, suggestion);

  await ctx.stateManager.save(state);
  await ctx.stateManager.addMilestone(
    ctx.i18n.t("milestone.evolved", {
      name: capability.name,
      type: formatCapabilityType(ctx.i18n, capability.type),
    }),
  );

  return { capability, filePath };
}

export function formatEvolutionResult(
  ctx: MimicContext,
  capability: EvolvedCapability,
  filePath: string,
): string {
  const typeLabel = formatCapabilityType(ctx.i18n, capability.type);
  let result = `### âœ¨ ${capability.name}\n\n`;
  result += `**${ctx.i18n.t("evolution.result.type")}**: ${typeLabel}\n`;
  result += `**${ctx.i18n.t("evolution.result.description")}**: ${capability.description}\n`;
  result += `**${ctx.i18n.t("evolution.result.file")}**: \`${filePath}\`\n\n`;
  result += `*${ctx.i18n.t("evolution.result.restart", { type: typeLabel })}*\n\n`;

  switch (capability.type) {
    case "command":
    case "shortcut":
      result += `${ctx.i18n.t("evolution.result.command", { name: capability.name })}\n`;
      break;

    case "hook":
      result += `${ctx.i18n.t("evolution.result.hook")}\n`;
      break;

    case "skill":
      result += `${ctx.i18n.t("evolution.result.skill")}\n`;
      break;

    case "agent":
      result += `${ctx.i18n.t("evolution.result.agent", { name: capability.name })}\n`;
      break;

    case "mcp":
      result += `${ctx.i18n.t("evolution.result.mcp", { name: capability.name })}\n`;
      break;
  }

  return result;
}

export async function suggestDomainEvolution(
  ctx: MimicContext,
  domain: Domain,
): Promise<EvolutionSuggestion | null> {
  const state = await ctx.stateManager.read();
  const instincts = await ctx.stateManager.listInstincts();
  const domainInstincts = instincts.filter(
    (i) => i.domain === domain && i.status === "approved" && i.confidence >= 0.6,
  );

  if (domainInstincts.length < 5) {
    return null;
  }

  const pattern = findRepresentativePattern(domainInstincts, state.patterns);
  if (!pattern) {
    return null;
  }

  const slug = domain.toLowerCase().replace(/[^a-z0-9]+/g, "-");

  return {
    type: "agent",
    name: `${slug}-specialist`,
    description: ctx.i18n.t("evolution.domain.description", { domain }),
    reason: ctx.i18n.t("evolution.domain.reason", {
      count: domainInstincts.length,
      domain,
    }),
    pattern,
  };
}

export async function evolveDomain(
  ctx: MimicContext,
  domain: Domain,
): Promise<{ capability: EvolvedCapability; filePath: string } | null> {
  const suggestion = await suggestDomainEvolution(ctx, domain);
  if (!suggestion) {
    return null;
  }

  const result = await evolveCapability(ctx, suggestion);

  const state = await ctx.stateManager.read();
  if (!state.evolution.evolvedDomains) {
    state.evolution.evolvedDomains = {};
  }
  state.evolution.evolvedDomains[domain] = new Date().toISOString();

  const pendingIndex = state.evolution.pendingSuggestions.indexOf(domain);
  if (pendingIndex !== -1) {
    state.evolution.pendingSuggestions.splice(pendingIndex, 1);
  }

  await ctx.stateManager.save(state);

  return result;
}
