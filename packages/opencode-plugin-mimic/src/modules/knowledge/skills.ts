import { existsSync } from "node:fs";
import { mkdir, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type { MimicContext } from "@/core/context";
import type { Domain, EvolvedCapability, Instinct, Pattern } from "@/types";

/**
 * Skill metadata for declarative skill definition
 */
export interface SkillMetadata {
  name: string;
  description: string;
  trigger: "auto" | "manual" | "scheduled";
  domain: Domain;
  tools?: Record<string, boolean>;
}

/**
 * Generated skill output
 */
export interface GeneratedSkill {
  name: string;
  path: string;
  metadata: SkillMetadata;
  content: string;
}

/**
 * Generates declarative markdown-based skills from learned instincts.
 * Skills are saved to .opencode/skills/{name}/SKILL.md format.
 */
export class SkillGenerator {
  private readonly skillsDir: string;

  constructor(directory: string) {
    this.skillsDir = join(directory, ".opencode", "skills");
  }

  /**
   * Initialize skills directory
   */
  async initialize(): Promise<void> {
    if (!existsSync(this.skillsDir)) {
      await mkdir(this.skillsDir, { recursive: true });
    }
  }

  /**
   * Generate a skill from a cluster of instincts
   */
  async generateSkill(
    name: string,
    description: string,
    domain: Domain,
    instincts: Instinct[],
    patterns: Pattern[],
  ): Promise<GeneratedSkill> {
    const skillDir = join(this.skillsDir, name);
    if (!existsSync(skillDir)) {
      await mkdir(skillDir, { recursive: true });
    }

    const metadata: SkillMetadata = {
      name,
      description,
      trigger: "auto",
      domain,
      tools: this.inferTools(patterns),
    };

    const content = this.generateSkillMarkdown(metadata, instincts, patterns);
    const skillPath = join(skillDir, "SKILL.md");

    await writeFile(skillPath, content, "utf-8");

    return {
      name,
      path: skillPath,
      metadata,
      content,
    };
  }

  /**
   * Generate markdown content for a skill
   */
  private generateSkillMarkdown(
    metadata: SkillMetadata,
    instincts: Instinct[],
    patterns: Pattern[],
  ): string {
    const toolsYaml = metadata.tools
      ? Object.entries(metadata.tools)
          .map(([tool, enabled]) => `  ${tool}: ${enabled}`)
          .join("\n")
      : "  # No specific tools defined";

    const instinctsList = instincts
      .slice(0, 10)
      .map(
        (i) =>
          `- **${i.title}** (${Math.round(i.confidence * 100)}% confidence)\n  ${i.description}`,
      )
      .join("\n");

    const patternsList = patterns
      .slice(0, 5)
      .map((p) => `- ${p.type}: ${p.description} (${p.count}x observed)`)
      .join("\n");

    const now = new Date().toISOString();

    return `---
name: ${metadata.name}
description: ${metadata.description}
trigger: ${metadata.trigger}
domain: ${metadata.domain}
tools:
${toolsYaml}
generated: ${now}
---

# ${metadata.name}

${metadata.description}

> [!NOTE]
> This skill was auto-generated by Mimic based on observed patterns and learned instincts.

## Overview

This skill encapsulates learned behaviors from repeated usage patterns in the **${metadata.domain}** domain.

## Learned Behaviors

${instinctsList || "No instincts documented yet."}

## Observed Patterns

${patternsList || "No patterns documented yet."}

## Usage Guidelines

### When to Apply

This skill should be activated when:
${this.generateUsageConditions(metadata.domain, patterns)}

### Best Practices

${this.generateBestPractices(metadata.domain, instincts)}

## Context

- **Domain**: ${metadata.domain}
- **Generated**: ${now}
- **Instincts Used**: ${instincts.length}
- **Patterns Analyzed**: ${patterns.length}

## Customization

You can customize this skill by editing the frontmatter or adding additional sections below.

---

*Generated by [opencode-plugin-mimic](https://github.com/gracefullight/pkgs)*
`;
  }

  /**
   * Generate usage conditions based on domain and patterns
   */
  private generateUsageConditions(domain: Domain, patterns: Pattern[]): string {
    const conditions: string[] = [];

    switch (domain) {
      case "testing":
        conditions.push("- Working with test files (*.test.ts, *.spec.ts)");
        conditions.push("- Running test suites or debugging test failures");
        break;
      case "git":
        conditions.push("- Preparing commits or managing branches");
        conditions.push("- Reviewing code changes before push");
        break;
      case "debugging":
        conditions.push("- Investigating errors or unexpected behavior");
        conditions.push("- Adding logging or tracing code");
        break;
      case "code-style":
        conditions.push("- Formatting or linting code");
        conditions.push("- Enforcing coding conventions");
        break;
      case "refactoring":
        conditions.push("- Restructuring code without changing behavior");
        conditions.push("- Extracting functions or classes");
        break;
      case "documentation":
        conditions.push("- Writing or updating documentation");
        conditions.push("- Adding code comments or JSDoc");
        break;
      case "file-organization":
        conditions.push("- Moving or renaming files");
        conditions.push("- Organizing project structure");
        break;
      case "tooling":
        conditions.push("- Configuring build tools or scripts");
        conditions.push("- Managing dependencies");
        break;
      default:
        conditions.push("- General development tasks");
    }

    // Add pattern-specific conditions
    for (const pattern of patterns.slice(0, 3)) {
      if (pattern.type === "sequence") {
        conditions.push(`- Executing workflow: ${pattern.description}`);
      } else if (pattern.type === "file") {
        conditions.push(`- Working with: ${pattern.description}`);
      }
    }

    return conditions.join("\n");
  }

  /**
   * Generate best practices from instincts
   */
  private generateBestPractices(domain: Domain, instincts: Instinct[]): string {
    const practices: string[] = [];

    // Add instinct-based practices
    for (const instinct of instincts.filter((i) => i.confidence >= 0.7).slice(0, 5)) {
      practices.push(`1. ${instinct.title}`);
    }

    // Add domain-specific defaults if no instincts
    if (practices.length === 0) {
      switch (domain) {
        case "testing":
          practices.push("1. Write tests before implementation (TDD)");
          practices.push("2. Ensure high test coverage for critical paths");
          break;
        case "git":
          practices.push("1. Write clear, conventional commit messages");
          practices.push("2. Review changes before committing");
          break;
        case "code-style":
          practices.push("1. Follow established project conventions");
          practices.push("2. Run linters before committing");
          break;
        default:
          practices.push("1. Follow project conventions");
          practices.push("2. Document significant changes");
      }
    }

    return practices.join("\n");
  }

  /**
   * Infer required tools from patterns
   */
  private inferTools(patterns: Pattern[]): Record<string, boolean> {
    const tools: Record<string, boolean> = {
      read: true,
      glob: true,
      grep: true,
    };

    for (const pattern of patterns) {
      const desc = pattern.description.toLowerCase();

      if (desc.includes("edit") || desc.includes("write") || desc.includes("modify")) {
        tools.edit = true;
      }
      if (
        desc.includes("bash") ||
        desc.includes("shell") ||
        desc.includes("npm") ||
        desc.includes("pnpm")
      ) {
        tools.bash = true;
      }
      if (desc.includes("test") || desc.includes("vitest") || desc.includes("jest")) {
        tools.bash = true;
      }
    }

    return tools;
  }

  /**
   * Generate skill from an evolved capability
   */
  async fromCapability(
    ctx: MimicContext,
    capability: EvolvedCapability,
  ): Promise<GeneratedSkill | null> {
    const state = await ctx.stateManager.read();
    const instincts = await ctx.stateManager.listInstincts();

    // Find related pattern
    const pattern = state.patterns.find((p) => p.id === capability.fromPattern);
    if (!pattern) {
      return null;
    }

    // Find related instincts by domain
    const domainInstincts = instincts.filter((i) => {
      if (i.evidence.patternIDs.includes(pattern.id)) return true;
      return false;
    });

    // Determine domain
    const domain = domainInstincts[0]?.domain || "other";

    return this.generateSkill(capability.name, capability.description, domain, domainInstincts, [
      pattern,
    ]);
  }

  /**
   * Generate skills for all eligible domains
   */
  async generateAllEligibleSkills(ctx: MimicContext): Promise<GeneratedSkill[]> {
    const instincts = await ctx.stateManager.listInstincts();
    const state = await ctx.stateManager.read();
    const skills: GeneratedSkill[] = [];

    // Group instincts by domain
    const byDomain = new Map<Domain, Instinct[]>();
    for (const instinct of instincts) {
      if (instinct.status !== "approved" || instinct.confidence < 0.6) continue;
      const list = byDomain.get(instinct.domain) || [];
      list.push(instinct);
      byDomain.set(instinct.domain, list);
    }

    // Generate skills for domains with 5+ instincts
    for (const [domain, domainInstincts] of byDomain) {
      if (domainInstincts.length < 5) continue;

      const name = `${domain}-specialist`;
      const description = ctx.i18n.t("skill.domain_description", { domain });

      // Get related patterns
      const patternIds = new Set(domainInstincts.flatMap((i) => i.evidence.patternIDs));
      const patterns = state.patterns.filter((p) => patternIds.has(p.id));

      try {
        const skill = await this.generateSkill(
          name,
          description,
          domain,
          domainInstincts,
          patterns,
        );
        skills.push(skill);
      } catch {
        // Skip failed skill generations
      }
    }

    return skills;
  }
}
